.. _sec-matlab:

SFS Toolbox for Matlab/Octave
=============================

The Sound Field Synthesis Toolbox (SFS) for Matlab/Octave gives you the
possibility to play around with sound field synthesis methods like Wave
Field Synthesis (WFS) or near-field compensated Higher Order Ambisonics
(NFC-HOA). There are functions to simulate monochromatic sound fields
for different secondary source (loudspeaker) setups, time snapshots of
full band impulses emitted by the secondary source distributions, or
even generate Binaural Room Scanning (BRS) stimuli sets in order to
simulate WFS with the SoundScape Renderer (SSR).

This documentation is all about its usage, if you are interested in the
underlying mathematics you should have a look at its PDF documentation
`Theory of Sound Field
Synthesis <https://github.com/sfstoolbox/sfs-documentation/releases/latest>`__.

**Attention:** the SFS Toolbox now incorporates
`SOFA <http://sofaconventions.org/>`__ as file format for HRTFs which
replaces the old irs file format formerly used by the Toolbox. If you
still need this you should download `the latest version with irs file
support <https://github.com/sfstoolbox/sfs/releases/tag/1.2.0>`__.

Installation
------------

Download the Toolbox and add the main path of the Toolbox to your
Matlab/Octave path. After that have a look at SFS\_config.m and change
it to your needs. For an easy beginning you can just use the default
settings by leaving everything as it is. Then start the Toolbox with
SFS\_start which will add all needed subpathes.

Requirements
------------

**Matlab** You need Matlab version 2011b or newer to run the Toolbox. On
older version the Toolbox should also work, but you need to add
`narginchk.m <http://gist.github.com/hagenw/5642886>`__ to the
SFS\_helper directory.

**Octave** You need Octave version 3.6 or newer to run the Toolbox. In
addition, you will need the following additional packages from
`octave-forge <http://octave.sourceforge.net/>`__: \* audio (e.g. for
wavwrite) \* signal (e.g. for firls)

**Impulse responses** The Toolbox uses the
`SOFA <http://sofaconventions.org/>`__ file format for handling impulse
response data sets like HRTFs. If you want to use this functionality you
also have to install the `SOFA API for
Matlab/Octave <https://github.com/sofacoustics/API_MO>`__, which you can
add to your paths by executing ``SOFAstart``.

After setting up the Toolbox you can made one of the magic following
things with it.

Usage
-----

Secondary sources
~~~~~~~~~~~~~~~~~

The Toolbox comes with a function which can generate different common
shapes of loudspeaker arrays for you. At the moment linear, circular,
box shaped and spherical arrays are included out of the box.

Before showing the different geometries, we start with some common
settings. First we get a configuration struct and set the array
size/diameter to 3m.

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.size = 3;

Linear array
^^^^^^^^^^^^

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.geometry = 'line'; % or 'linear'
    conf.secondary_sources.number = 21;
    x0 = secondary_source_positions(conf);
    figure;
    figsize(conf.plot.size(1),conf.plot.size(2),conf.plot.size_unit);
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2 1]);
    %print_png('img/secondary_sources_linear.png');

.. figure:: img/secondary_sources_linear.png
   :align: center

   Image

Circular array
^^^^^^^^^^^^^^

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.geometry = 'circle'; % or 'circular'
    conf.secondary_sources.number = 56;
    x0 = secondary_source_positions(conf);
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2 2]);
    %print_png('img/secondary_sources_circle.png');

.. figure:: img/secondary_sources_circle.png
   :align: center

   Image

Box shaped array
^^^^^^^^^^^^^^^^

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.geometry = 'box';
    conf.secondary_sources.number = 84;
    x0 = secondary_source_positions(conf);
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2 2]);
    %print_png('img/secondary_sources_box.png');

.. figure:: img/secondary_sources_box.png
   :align: center

   Image

Box shaped array with rounded edges
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

conf.secondary\_sources.edge\_radius defines the bending radius of the
corners. It can be chosen in a range between 0.0 and the half of
conf.secondary\_sources.size. While the prior represents a square box
the latter yields a circle. Note that the square box behaves it little
bit different than the Box Shaped Array since loudspeakers might also be
place directly in the corners of the box.

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.geometry = 'rounded-box';
    conf.secondary_sources.number = 84;
    conf.secondary_sources.corner_radius = 0.3;
    x0 = secondary_source_positions(conf);
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2 2]);
    %print_png('img/secondary_sources_rounded-box.png');

.. figure:: img/secondary_sources_rounded-box.png
   :align: center

   Image

Spherical array
^^^^^^^^^^^^^^^

For a spherical array you need a grid to place the secondary sources on
the sphere. At the moment we provide grids with the Toolbox, that can be
find here:
http://github.com/sfstoolbox/data/tree/master/spherical\_grids You have
to specify your desired grid, for example conf.secondary\_sources.grid =
'equally\_spaced\_points'. The secondary\_source\_positions() functions
will then automatically download the desired grid from that web page and
stores it under <code><$SFS\_MAIN\_PATH>/data. If the download is not
working (which can happen under Matlab and Windows at the moment) you
can alternatively checkout or download the whole `data
repository <http://github.com/sfstoolbox/data>`__ to the data folder.

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.size = 3;
    conf.secondary_sources.geometry = 'sphere'; % or 'spherical'
    conf.secondary_sources.grid = 'equally_spaced_points';
    conf.secondary_sources.number = 225;
    x0 = secondary_source_positions(conf);
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2 2]);
    %print_png('img/secondary_sources_sphere.png');

.. figure:: img/secondary_sources_sphere.png
   :align: center

   Image

Arbitrary shaped arrays
^^^^^^^^^^^^^^^^^^^^^^^

You can create arbitrarily shaped arrays by setting
conf.secondary\_sources.geometry to 'custom' and define the values of
the single loudspeaker directly in the conf.secondary\_sources.x0
matrix. The rows of the matrix contain the single loudspeakers and the
six columns are [x y z nx ny nz w], the position and direction and
weight of the single loudspeakers. The weight w is a factor the driving
function of this particular loudspeaker is multiplied with in a function
that calculates the sound field from the given driving signals and
secondary sources. For WFS w could include the tapering window, a
spherical grid weight, and the r^2 cos(theta) weights for integration on
a sphere.

.. code:: matlab

    conf = SFS_config;
    % create a stadium like shape by combining two half circles with two linear
    % arrays
    % first getting a full circle with 56 loudspeakers
    conf.secondary_sources.geometry = 'circle';
    conf.secondary_sources.number = 56;
    conf.secondary_sources.x0 = [];
    x0 = secondary_source_positions(conf);
    % store the first half cricle and move it up
    x01 = x0(2:28,:);
    x01(:,2) = x01(:,2) + ones(size(x01,1),1)*0.5;
    % store the second half circle and move it down
    x03 = x0(30:56,:);
    x03(:,2) = x03(:,2) - ones(size(x03,1),1)*0.5;
    % create a linear array
    conf.secondary_sources.geometry = 'line';
    conf.secondary_sources.number = 7;
    conf.secondary_sources.size = 1;
    x0 = secondary_source_positions(conf);
    % rotate it and move it left
    R = rotation_matrix(pi/2);
    x02 = [(R*x0(:,1:3)')' (R*x0(:,4:6)')'];
    x02(:,1) = x02(:,1) - ones(size(x0,1),1)*1.5;
    x02(:,7) = x0(:,7);
    % rotate it the other way around and move it right
    R = rotation_matrix(-pi/2);
    x04 = [(R*x0(:,1:3)')' (R*x0(:,4:6)')'];
    x04(:,1) = x04(:,1) + ones(size(x0,1),1)*1.5;
    x04(:,7) = x0(:,7);
    % combine everything
    conf.secondary_sources.geometry = 'custom';
    conf.secondary_sources.x0 = [x01; x02; x03; x04];
    % if we gave the conf.x0 to the secondary_source_positions function it will
    % simply return the defined x0 matrix
    x0 = secondary_source_positions(conf);
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2.5 2.5]);
    %print_png('img/secondary_sources_arbitrary.png');

.. figure:: img/secondary_sources_arbitrary.png
   :align: center

   Image

Plot loudspeaker symbols
^^^^^^^^^^^^^^^^^^^^^^^^

For two dimensional setups you can plot the secondary sources with
loudspeaker symbols, for example the following will replot the last
array.

.. code:: matlab

    conf.plot.realloudspeakers = true;
    figure;
    figsize(540,404,'px');
    draw_loudspeakers(x0,conf);
    axis([-2 2 -2.5 2.5]);
    %print_png('img/secondary_sources_arbitrary_realloudspeakers.png');

.. figure:: img/secondary_sources_arbitrary_realloudspeakers.png
   :align: center

   Image

Simulate monochromatic sound fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With the files in SFS\_monochromatic you can simulate a monochromatic
sound field in a specified area for different techniques like WFS and
NFC-HOA. The area can be a 3D cube, a 2D plane, a line or only one
point. This depends on the specification of X,Y,Z. For example [-2
2],[-2 2],[-2 2] will be a 3D cube; [-2 2],0,[-2 2] the xz-plane; [-2
2],0,0 a line along the x-axis; 3,2,1 a single point. If you present a
range like ``[-2 2]`` the Toolbox will create automatically a regular
grid from this ranging from -2 to 2 with ``conf.resolution`` steps in
between. Alternatively you could apply a `custom
grid <#custom-grid-for-sound-field-simulations>`__ by providing a matrix
instead of the ``[min max]`` range for all active axes.

For all 2.5D functions the configuration conf.xref is important as it
defines the point for which the amplitude is corrected in the sound
field. The default entry is

.. code:: matlab

    conf.xref = [0 0 0];

Make sure, that this point is inside your listening area.

Wave Field Synthesis
^^^^^^^^^^^^^^^^^^^^

The following will simulate the field of a virtual plane wave with a
frequency of 800 Hz going into the direction of (0 -1 0) synthesized
with 3D WFS.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '3D';
    conf.secondary_sources.size = 3;
    conf.secondary_sources.number = 225;
    conf.secondary_sources.geometry = 'sphere';
    % [P,x,y,z,x0,win] = sound_field_mono_wfs(X,Y,Z,xs,src,f,conf);
    sound_field_mono_wfs([-2 2],[-2 2],0,[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_wfs_3d_xy.png');
    sound_field_mono_wfs([-2 2],0,[-2 2],[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_wfs_3d_xz.png');
    sound_field_mono_wfs(0,[-2 2],[-2 2],[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_wfs_3d_yz.png');

.. figure:: img/sound_field_wfs_3d_xy.png
   :align: center

   Image

.. figure:: img/sound_field_wfs_3d_xz.png
   :align: center

   Image

.. figure:: img/sound_field_wfs_3d_yz.png
   :align: center

   Image

You can see that the Toolbox is now projecting all the secondary source
positions into the plane for plotting them. In addition the axis are
automatically chosen and labeled.

It is also possible to simulate and plot the whole 3D cube, but in this
case no secondary sources will be added to the plot.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '3D';
    conf.secondary_sources.size = 3;
    conf.secondary_sources.number = 225;
    conf.secondary_sources.geometry = 'sphere';
    conf.resolution = 100;
    sound_field_mono_wfs([-2 2],[-2 2],[-2 2],[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_wfs_3d_xyz.png');

.. figure:: img/sound_field_wfs_3d_xyz.png
   :align: center

   Image

In the next plot we use a two dimensional array, 2.5D WFS and a virtual
point source located at (0 2.5 0) m. The 3D example showed you, that the
sound fields are automatically plotted if we specify now output
arguments. If we specify one, we have to explicitly say if we want also
plot the results, by conf.plot.useplot = true;.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '2.5D';
    conf.plot.useplot = true;
    conf.plot.normalisation = 'center';
    % [P,x,y,z,x0] = sound_field_mono_wfs(X,Y,Z,xs,src,f,conf);
    [P,x,y,z,x0] = sound_field_mono_wfs([-2 2],[-2 2],0,[0 2.5 0],'ps',800,conf);
    %print_png('img/sound_field_wfs_25d.png');

.. figure:: img/sound_field_wfs_25d.png
   :align: center

   Image

If you want to plot the whole loudspeaker array and not only the active
secondary sources, you can do this by adding these commands. First we
store all sources in an extra variable x0\_all, then we get the active
ones x0 and the corresponding indices of these active ones in x0\_all.
Afterwards we set all sources in x0\_all to zero, which is inactive and
only the active ones to x0(:,7).

.. code:: matlab

    x0_all = secondary_source_positions(conf);
    [x0,idx] = secondary_source_selection(x0_all,[0 2.5 0],'ps');
    x0_all(:,7) = zeros(1,size(x0_all,1));
    x0_all(idx,7) = x0(:,7);
    plot_sound_field(P,x,y,z,x0_all,conf);
    %print_png('img/sound_field_wfs_25d_with_all_sources.png');

.. figure:: img/sound_field_wfs_25d_with_all_sources.png
   :align: center

   Image

Near-Field Compensated Higher Order Ambisonics
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the following we will simulate the field of a virtual plane wave with
a frequency of 800 Hz traveling into the direction (0 -1 0), synthesized
with 2.5D NFC-HOA.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '2.5D';
    % sound_field_mono_nfchoa(X,Y,Z,xs,src,f,conf);
    sound_field_mono_nfchoa([-2 2],[-2 2],0,[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_nfchoa_25d.png');

.. figure:: img/sound_field_nfchoa_25d.png
   :align: center

   Image

Local Wave Field Synthesis
^^^^^^^^^^^^^^^^^^^^^^^^^^

In NFC-HOA the aliasing frequency in a small region inside the listening
area can be increased by limiting the used order. A similar outcome can
be achieved in WFS by applying so called local Wave Field Synthesis. In
this case the original loudspeaker array is driven by WFS to create a
virtual loudspeaker array consisting of focused sources which can then
be used to create the desired sound field in a small area. The settings
are the same as for WFS, but a new struct conf.localsfs has to be filled
out, which for example provides the settings for the desired position
and form of the local region with higher aliasing frequency, have a look
into ``SFS_config.m`` for all possible settings.

.. code:: matlab

    conf = SFS_config;
    conf.resolution = 1000;
    conf.dimension = '2D';
    conf.secondary_sources.geometry = 'box';
    conf.secondary_sources.number = 4*56;
    conf.secondary_sources.size = 2;
    conf.localsfs.vss.size = 0.4;
    conf.localsfs.vss.center = [0 0 0];
    conf.localsfs.vss.geometry = 'circular';
    conf.localsfs.vss.number = 56;
    % sound_field_mono_localwfs(X,Y,Z,xs,src,f,conf);
    sound_field_mono_localwfs([-1 1],[-1 1],0,[1.0 -1.0 0],'pw',7000,conf);
    axis([-1.1 1.1 -1.1 1.1]);
    %print_png('img/sound_field_localwfs_2d.png');

.. figure:: img/sound_field_localwfs_2d.png
   :align: center

   Image

Stereo
^^^^^^

The Toolbox includes not only WFS and NFC-HOA, but also some generic
sound field functions that are doing only the integration of the driving
signals of the single secondary sources to the resulting sound field.
With these function you can for example easily simulate a stereophonic
setup. In this example we set the
``conf.plot.normalisation = 'center';`` configuration manually as the
amplitude of the sound field is too low for the default ``'auto'``
setting to work.

.. code:: matlab

    conf = SFS_config;
    conf.plot.normalisation = 'center';
    x0 = [-1 2 0 0 -1 0 1;1 2 0 0 -1 0 1];
    % [P,x,y,z] = sound_field_mono(X,Y,Z,x0,src,D,f,conf)
    sound_field_mono([-2 2],[-1 3],0,x0,'ps',[1 1],800,conf)
    %print_png('img/sound_field_stereo.png');

.. figure:: img/sound_field_stereo.png
   :align: center

   Image

Simulate time snapshots of sound fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With the files in SFS\_time\_domain you can simulate snapshots in time
of an impulse originating from your WFS or NFC-HOA system.

In the following we will create a snapshot in time after 200 samples for
a broadband virtual point source placed at (0 2 0) m for 2.5D NFC-HOA.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '2.5D';
    conf.plot.useplot = true;
    % sound_field_imp_nfchoa(X,Y,Z,xs,src,t,conf)
    [p,x,y,z,x0] = sound_field_imp_nfchoa([-2 2],[-2 2],0,[0 2 0],'ps',200,conf);
    %print_png('img/sound_field_imp_nfchoa_25d.png');

.. figure:: img/sound_field_imp_nfchoa_25d.png
   :align: center

   Image

The output can also be plotted in dB by setting conf.plot.usedb = true;.
In this case the default color map is changed and a color bar is plotted
in the figure. For none dB plots no color bar is shown in the plots. In
these cases the color coding goes always from -1 to 1, with clipping of
larger values.

.. code:: matlab

    conf.plot.usedb = true;
    plot_sound_field(p,[-2 2],[-2 2],0,x0,conf);
    %print_png('img/sound_field_imp_nfchoa_25d_dB.png');

.. figure:: img/sound_field_imp_nfchoa_25d_dB.png
   :align: center

   Image

You could change the color map yourself doing the following before the
plot command.

.. code:: matlab

    conf.plot.colormap = 'jet'; % Matlab rainbow color map

If you want to simulate more than one virtual source, it is a good idea
to set the starting time of your simulation to start with the activity
of your virtual source and not the secondary sources, which is the
default behavior. You can change this by setting
``conf.wfs.t0 = 'source'``.

.. code:: matlab

    conf.plot.useplot = false;
    conf.wfs.t0 = 'source';
    t_40cm = round(0.4/conf.c*conf.fs); % in samples
    [p_ps,~,~,~,x0_ps] = ...
        sound_field_imp_wfs([-2 2],[-2 2],0,[1.9 0 0],'ps',20+t_40cm,conf);
    [p_pw,~,~,~,x0_pw] = ...
        sound_field_imp_wfs([-2 2],[-2 2],0,[1 -2 0],'pw',20-t_40cm,conf);
    [p_fs,~,~,~,x0_fs] = ...
        sound_field_imp_wfs([-2 2],[-2 2],0,[0 -1 0 0 1 0],'fs',20,conf);
    plot_sound_field(p_ps+p_pw+p_fs,[-2 2],[-2 2],0,[x0_ps; x0_pw; x0_fs],conf)
    hold;
    scatter(0,0,'kx');   % origin of plane wave
    scatter(1.9,0,'ko'); % point source
    scatter(0,-1,'ko');  % focused source
    hold off;
    %print_png('sound_field_imp_multiple_sources_dB.png');

.. figure:: img/sound_field_imp_multiple_sources_dB.png
   :align: center

   Image

Custom grid for sound field simulations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As stated earlier you can provide the sound field simulation functions a
custom grid instead of the ``[min max]`` ranges. Again, you can provide
it for one dimension, two dimensions, or all three dimensions.

.. code:: matlab

    conf = SFS_config;
    conf.dimension = '3D';
    conf.secondary_sources.number = 225;
    conf.secondary_sources.geometry = 'sphere';
    conf.resolution = 100;
    conf.plot.normalisation = 'center';
    X = randi([-2000 2000],125000,1)/1000;
    Y = randi([-2000 2000],125000,1)/1000;
    Z = randi([-2000 2000],125000,1)/1000;
    sound_field_mono_wfs(X,Y,Z,[0 -1 0],'pw',800,conf);
    %print_png('img/sound_field_wfs_3d_xyz_custom_grid.png');
    conf.plot.usedb = true;
    conf.dimension = '2.5D';
    conf.secondary_sources.number = 64;
    conf.secondary_sources.geometry = 'circle';
    sound_field_imp_nfchoa(X,Y,0,[0 2 0],'ps',200,conf);
    %print_png('img/sound_field_imp_nfchoa_25d_dB_custom_grid.png');

.. figure:: img/sound_field_wfs_3d_xyz_custom_grid.png
   :align: center

   Image

.. figure:: img/sound_field_imp_nfchoa_25d_dB_custom_grid.png
   :align: center

   Image

Make binaural simulations of your systems
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have a set of head-related transfer functions (HRTFs) or binaural
room impulse responses (BRIRs) you can simulate the ear signals reaching
a listener sitting at a given point in the listening area for different
spatial audio systems.

In order to easily use different HRTF or BRIR sets the Toolbox uses the
`SOFA file format <http://sofaconventions.org>`__. In order to use it
you have to install the `SOFA API for
Matlab/Octave <https://github.com/sofacoustics/API_MO>`__ and run
``SOFAstart`` before you can use it inside the SFS Toolbox. If you are
looking for different HRTFs and BRIRs, a large set of different impulse
responses is available:
http://www.sofaconventions.org/mediawiki/index.php/Files.

The files dealing with the binaural simulations are in the folder
SFS\_binaural\_synthesis. Files dealing with HRTFs and BRIRs are in the
folder SFS\_ir. If you want to extrapolate your HRTFs to plane waves you
may also want to have a look in the folder SFS\_HRTF\_extrapolation.

In the following we present some examples of binaural simulations. For
their auralization an anechoic recording of a cello is used, which can
be downloaded from
`anechoic\_cello.wav <https://dev.qu.tu-berlin.de/projects/twoears-database/repository/revisions/master/raw/stimuli/anechoic/instruments/anechoic_cello.wav>`__.

Binaural simulation of arbitrary loudspeaker arrays
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. figure:: img/tu_berlin_hrtf.jpg
   :align: center

   Image

If you use an HRTF data set, it has the advantage that it was recorded
in anechoic conditions and the only parameter that matters is the
relative position of the loudspeaker to the head during the measurement.
This advantage can be used to create every possible loudspeaker array
you can imagine, given that the relative locations of all loudspeakers
are available in the HRTF data set. The above picture shows an example
of a HRTF measurement. You can download the corresponding
`QU\_KEMAR\_anechoic\_3m.sofa <https://github.com/sfstoolbox/data/raw/master/HRTFs/QU_KEMAR_anechoic_3m.sofa>`__
HRTF set, which we can directly use with the Toolbox.

The following example will load the HRTF data set and extracts a single
impulse response for an angle of 30° from it. If the desired angle of
30° is not available, a linear interpolation between the next two
available angles will be applied. Afterwards the impulse response will
be convolved with the cello recording by the auralize\_ir() function.

.. code:: matlab

    conf = SFS_config;
    hrtf = SOFAload('QU_KEMAR_anechoic_3m.sofa');
    ir = get_ir(hrtf,[0 0 0],[0 0],[rad(30) 0 3],'spherical',conf);
    cello = wavread('anechoic_cello.wav');
    sig = auralize_ir(ir,cello,1,conf);
    sound(sig,conf.fs);

To simulate the same source as a virtual point source synthesized by WFS
and a circular array with a diameter of 3 m, you have to do the
following.

.. code:: matlab

    conf = SFS_config;
    conf.secondary_sources.size = 3;
    conf.secondary_sources.number = 56;
    conf.secondary_sources.geometry = 'circle';
    conf.dimension = '2.5D';
    hrtf = SOFAload('QU_KEMAR_anechoic_3m.sofa');
    % ir = ir_wfs(X,phi,xs,src,hrtf,conf);
    ir = ir_wfs([0 0 0],pi/2,[0 3 0],'ps',hrtf,conf);
    cello = wavread('anechoic_cello.wav');
    sig = auralize_ir(ir,cello,1,conf);

If you want to use binaural simulations in listening experiments, you
should not only have the HRTF data set, but also a corresponding
headphone compensation filter, which was recorded with the same dummy
head as the HRTFs and the headphones you are going to use in your test.
For the HRTFs we used in the last example and the AKG K601 headphones
you can download
`QU\_KEMAR\_AKGK601\_hcomp.wav <https://raw.githubusercontent.com/sfstoolbox/data/master/headphone_compensation/QU_KEMAR_AKGK601_hcomp.wav>`__.
If you want to redo the last simulation with headphone compensation,
just add the following lines before calling ``ir_wfs()``.

.. code:: matlab

    conf.ir.usehcomp = true;
    conf.ir.hcompfile = 'QU_KEMAR_AKGK601_hcomp.wav';
    conf.N = 4096;

The last setting ensures that your impulse response will be long enough
for convolution with the compensation filter.

Binaural simulation of a real setup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. figure:: img/university_rostock_loudspeaker_array.jpg
   :align: center

   Image

Besides simulating arbitrary loudspeaker configurations in an anechoic
space, you can also do binaural simulations of real loudspeaker setups.
In the following example we use BRIRs from the 64-channel loudspeaker
array of the University Rostock as shown in the panorama photo above.
The BRIRs and additional information on the recordings are available for
download, see
`doi:10.14279/depositonce-87.2 <http://dx.doi.org/10.14279/depositonce-87.2>`__.
For such a measurement the SOFA file format has the advantage to be able
to include all loudspeakers and head orientations in just one file.

.. code:: matlab

    conf = SFS_config;
    brir = 'BRIR_AllAbsorbers_ArrayCentre_Emitters1to64.sofa';
    conf.secondary_sources.geometry = 'custom';
    conf.secondary_sources.x0 = brir;
    conf.N = 44100;
    ir = ir_wfs([0 0 0],0,[3 0 0],'ps',brir,conf);
    cello = wavread('anechoic_cello.wav');
    sig = auralize_ir(ir,cello,1,conf);

In this case, we don't load the BRIRs into the memory with
``SOFAload()`` as the file is too large. Instead, we make use of the
ability that SOFA can request single impulse responses from the file by
just passing the file name to the ``ir_wfs()`` function. In addition, we
have to set ``conf.N`` to a reasonable large value as this determines
the length of the impulse response ``ir_wfs()`` will return, which has
to be larger as for the anechoic case as it should now include the room
reflections. Note, that the head orientation is chosen to be ``0``
instead of ``pi/2`` as in the HRTF examples due to a difference in the
orientation of the coordinate system of the BRIR measurement.

Frequency response of your spatial audio system
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Binaural simulations are also a nice way to investigate the frequency
response of your reproduction system. The following code will
investigate the influence of the pre-equalization filter in WFS on the
frequency response. For the red line the pre-filter is used and its
upper frequency is set to the expected aliasing frequency of the system
(above these frequency the spectrum becomes very noise as you can see in
the figure).

.. code:: matlab

    conf = SFS_config;
    conf.ir.usehcomp = false;
    conf.wfs.usehpre = false;
    hrtf = dummy_irs(conf);
    [ir1,x0] = ir_wfs([0 0 0],pi/2,[0 2.5 0],'ps',hrtf,conf);
    conf.wfs.usehpre = true;
    conf.wfs.hprefhigh = aliasing_frequency(x0,conf);
    ir2 = ir_wfs([0 0 0],pi/2,[0 2.5 0],'ps',hrtf,conf);
    [a1,p,f] = easyfft(norm_signal(ir1(:,1)),conf);
    a2 = easyfft(norm_signal(ir2(:,1)),conf);
    figure;
    figsize(540,404,'px');
    semilogx(f,20*log10(a1),'-b',f,20*log10(a2),'-r');
    axis([10 20000 -80 -40]);
    set(gca,'XTick',[10 100 250 1000 5000 20000]);
    legend('w/o pre-filter','w pre-filter');
    xlabel('frequency / Hz');
    ylabel('magnitude / dB');
    %print_png('img/impulse_response_wfs_25d.png');

.. figure:: img/impulse_response_wfs_25d.png
   :align: center

   Image

The same can be done in the frequency domain, but in this case we are
not able to set a maximum frequency of the pre-equalization filter and
the whole frequency range will be affected.

.. code:: matlab

    freq_response_wfs([0 0 0],[0 2.5 0],'ps',conf);
    axis([10 20000 -40 0]);
    %print_png('img/impulse_response_wfs_25d_mono.png');

.. figure:: img/impulse_response_wfs_25d_mono.png
   :align: center

   Image

Using the SoundScape Renderer with the SFS Toolbox
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to binaural synthesis, you may want to apply dynamic
binaural synthesis, which means you track the position of the head of
the listener and switches the used impulse responses regarding the head
position. The `SoundScape Renderer
(SSR) <http://spatialaudio.net/ssr/>`__ is able to do this. The SFS
Toolbox provides functions to generate the needed wav files containing
the impulse responses used by the SoundScape Renderer. All functions
regarding the SSR are stored in SFS\_ssr.

.. code:: matlab

    conf = SFS_config;
    brs = ssr_brs_wfs(X,phi,xs,src,hrtf,conf);
    wavwrite(brs,fs,16,'brs_set_for_SSR.wav');

Small helper functions
~~~~~~~~~~~~~~~~~~~~~~

The Toolbox provides you also with a set of useful small functions. Here
the highlights are angle conversion with rad() and deg(), FFT
calculation and plotting easyfft(), create noise signal noise(),
rotation matrix rotation\_matrix(), multi-channel convolution
convolution(), nearest neighbour search findnearestneighbour(), even or
odd checking iseven() isodd(), spherical bessel functions sphbesselh()
sphbesselj() sphbessely().

Plotting with Matlab/Octave or gnuplot
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Toolbox provides you with a variety of functions for plotting your
simulated sound fields plot\_sound\_field() and adding loudspeaker
symbols to the figure draw\_loudspeakers(). If you have gnuplot
installed, you can use the functions gp\_save\_matrix() and
gp\_save\_loudspeakers() to save your data in a way that it can be used
with gnuplot. An example use case can be found `at this plot of a plane
wave <https://github.com/hagenw/phd-thesis/tree/master/02_theory_of_sound_field_synthesis/fig2_04>`__
which includes the Matlab/Octave code to generate the data and the
gnuplot script for plotting it.

Credits and license
-------------------

This is the source distribution of Sound Field Synthesis Toolbox (SFS)
licensed under the GPLv3+. Please consult the file COPYING for more
information about this license.

Website: http://github.com/sfstoolbox/sfs

If you have questions, bug reports or feature requests, please use the
`Issue Section on the
website <https://github.com/sfstoolbox/sfs/issues>`__ to report them.

| If you use the Toolbox for your publications please cite our AES
  Convention e-Brief and/or the DOI you will find for the `official
  releases <https://github.com/sfstoolbox/sfs/releases>`__:
| H. Wierstorf, S. Spors - Sound Field Synthesis Toolbox. In the
  Proceedings of *132nd Convention of the Audio Engineering Society*,
  2012 [
  `pdf <http://audio.qu.tu-berlin.de/wp-content/uploads/publications/2012/wierstorf2012_SFS_toolbox_AES.pdf>`__
  ][ `bibtex <doc/aes132_paper.bib>`__ ]

Copyright (c) 2010-2016 Quality & Usability Lab, together with
Assessment of IP-based Applications Telekom Innovation Laboratories, TU
Berlin Ernst-Reuter-Platz 7, 10587 Berlin, Germany

Copyright (c) 2013-2016 Institut fuer Nachrichtentechnik Universitaet
Rostock Richard-Wagner-Strasse 31, 18119 Rostock

.. vim: filetype=rst spell:
